<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Î”.E.F.I.R Term Parser</title>
  <style>
    body { font-family: sans-serif; padding: 2rem; background: #111; color: #eee; }
    input, button { padding: 0.5rem; margin: 1rem 0; }
    textarea { width: 100%; height: 200px; margin-top: 1rem; background: #222; color: #0f0; white-space: pre; }
  </style>
</head>
<body>
  <h1>ðŸ“˜ Î”.E.F.I.R Term Parser</h1>
  <input type="file" id="fileInput" accept=".txt">
  <button onclick="handleFile()">ðŸ“¥ Ð—Ð°Ð³Ñ€ÑƒÐ·Ð¸Ñ‚ÑŒ Ð¸ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ñ‚ÑŒ</button>
  <button onclick="downloadJson()">ðŸ’¾ Ð¡ÐºÐ°Ñ‡Ð°Ñ‚ÑŒ JSON</button>
  <textarea id="output" readonly placeholder="JSON Ð¿Ð¾ÑÐ²Ð¸Ñ‚ÑÑ Ð·Ð´ÐµÑÑŒ..."></textarea>

  <script>
    let parsedJson = '';

    function handleFile() {
      const file = document.getElementById('fileInput').files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        parsedJson = parseTermLog(reader.result);
        document.getElementById('output').value = parsedJson;
      };
      reader.readAsText(file);
    }

    function downloadJson() {
      if (!parsedJson) return;
      const blob = new Blob([parsedJson], { type: 'application/json' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = 'defir_log.json';
      link.click();
    }

    function parseTermLog(text) {
      const termLog = [];
      const realityAnalysis = [];
      const entries = text.split(/(?=^>\s*Ð¢Ð•Ð ÐœÐ˜Ð_|^â–ŒÎ”\.1\.REALITY_ANALYSIS)/gm);

      const getBlock = (block, label) => {
        const regex = new RegExp(`â–  ${label}:[\s\S]*?(?=^\s*â–  |^\s*> |^\s*â–Œ|$)`, 'gm');
        const match = block.match(regex);
        if (!match) return null;
        return match[0].split(':').slice(1).join(':').trim().replace(/\r/g, '').replace(/\n/g, ' ');
      };

      const getList = (block, label) => {
        const regex = new RegExp(`â–  ${label}:[\s\S]*?(?=^\s*â–  |^\s*> |^\s*â–Œ|$)`, 'gm');
        const match = block.match(regex);
        if (!match) return [];
        return [...match[0].matchAll(/- (.+)/g)].map(m => m[1].trim());
      };

      const getQuotes = (block, label) => {
        const regex = new RegExp(`â–  ${label}:[\s\S]*?(?=^\s*â–  |^\s*> |^\s*â–Œ|$)`, 'gm');
        const match = block.match(regex);
        if (!match) return [];
        return [...match[0].matchAll(/"(.+?)"/g)].map(m => m[1]);
      };

      entries.forEach(block => {
        const termMatch = block.match(/Ð¢Ð•Ð ÐœÐ˜Ð_(\d+): Â«(.+?)Â»/);
        if (termMatch) {
          const id = termMatch[1];
          const name = termMatch[2];

          const obj = {
            id,
            name,
            category: 'standard',
            description: getBlock(block, 'ÐžÐ¿Ð¸ÑÐ°Ð½Ð¸Ðµ'),
            fieldDesignation: getBlock(block, 'ÐŸÐ¾Ð»ÐµÐ²Ð¾Ðµ Ð¾Ð±Ð¾Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ'),
            status: getBlock(block, 'Ð¡Ð¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ'),
            risks: getList(block, 'Ð¡Ð¾Ð¿ÑƒÑ‚ÑÑ‚Ð²ÑƒÑŽÑ‰Ð¸Ðµ Ñ€Ð¸ÑÐºÐ¸'),
            anomalies: getList(block, 'ÐÐ°Ð±Ð»ÑŽÐ´Ð°ÐµÐ¼Ñ‹Ðµ Ð°Ð½Ð¾Ð¼Ð°Ð»Ð¸Ð¸'),
            functions: getList(block, 'Ð¤ÑƒÐ½ÐºÑ†Ð¸Ð¸'),
            gradations: getList(block, 'Ð“Ñ€Ð°Ð´Ð°Ñ†Ð¸Ð¸'),
            characteristics: getList(block, 'Ð¥Ð°Ñ€Ð°ÐºÑ‚ÐµÑ€Ð¸ÑÑ‚Ð¸ÐºÐ¸'),
            properties: getList(block, 'Ð¡Ð²Ð¾Ð¹ÑÑ‚Ð²Ð°'),
            comments: getQuotes(block, 'ÐšÐ¾Ð¼Ð¼ÐµÐ½Ñ‚Ð°Ñ€Ð¸Ð¹'),
            notes: getQuotes(block, 'ÐŸÑ€Ð¸Ð¼ÐµÑ‡Ð°Ð½Ð¸Ðµ')
          };

          const known = Object.keys(obj).concat(['id', 'name', 'category']);
          const extraMatches = [...block.matchAll(/^â–  ([^:\n]+):\s+([\s\S]*?)(?=^\s*â–  |^\s*> |^\s*â–Œ|$)/gm)];
          extraMatches.forEach(([, key, value]) => {
            if (!known.includes(key.trim())) {
              if (!obj.extraFields) obj.extraFields = {};
              obj.extraFields[key.trim()] = value.trim().replace(/\r/g, '').replace(/\n/g, ' ');
            }
          });

          for (const key in obj) if (!obj[key] || (Array.isArray(obj[key]) && !obj[key].length)) delete obj[key];
          termLog.push(obj);
        }

        const anomalyMatch = block.match(/REALITY_ANALYSIS[\s\S]*?Ð˜Ð”Ð•ÐÐ¢Ð˜Ð¤Ð˜ÐšÐÐ¢ÐžÐ : (.+)/);
        if (anomalyMatch) {
          const id = anomalyMatch[1].trim();

          const getField = label => {
            const match = block.match(new RegExp(`â–Œ${label}: (.+)`));
            return match ? match[1].trim() : null;
          };

          const obj = {
            id,
            status: getField('Ð¡Ð¢ÐÐ¢Ð£Ð¡'),
            object: getField('ÐžÐ‘ÐªÐ•ÐšÐ¢'),
            timepoint: getField('ÐœÐ•Ð¢ÐšÐ Ð’Ð Ð•ÐœÐ•ÐÐ˜'),
            event: getBlock(block, 'Ð¡Ð¾Ð±Ñ‹Ñ‚Ð¸Ðµ'),
            systemVersion: getBlock(block, 'Ð’ÐµÑ€ÑÐ¸Ñ ÑÐ¸ÑÑ‚ÐµÐ¼Ñ‹'),
            notes: getQuotes(block, 'ÐŸÑ€Ð¸Ð¼ÐµÑ‡Ð°Ð½Ð¸Ðµ'),
            recommendations: getList(block, 'Ð ÐµÐºÐ¾Ð¼ÐµÐ½Ð´Ð°Ñ†Ð¸Ð¸'),
            classification: getBlock(block, 'ÐšÐ»Ð°ÑÑÐ¸Ñ„Ð¸ÐºÐ°Ñ†Ð¸Ñ'),
            hypothesis: getBlock(block, 'Ð“Ð¸Ð¿Ð¾Ñ‚ÐµÐ·Ð° ÑÐ¸ÑÑ‚ÐµÐ¼Ñ‹'),
            directive: getBlock(block, 'Ð”Ð¸Ñ€ÐµÐºÑ‚Ð¸Ð²Ð°')
          };

          const known = Object.keys(obj).concat(['id']);
          const extraMatches = [...block.matchAll(/^â–  ([^:\n]+):\s+([\s\S]*?)(?=^\s*â–  |^\s*> |^\s*â–Œ|$)/gm)];
          extraMatches.forEach(([, key, value]) => {
            if (!known.includes(key.trim())) {
              if (!obj.extraFields) obj.extraFields = {};
              obj.extraFields[key.trim()] = value.trim().replace(/\r/g, '').replace(/\n/g, ' ');
            }
          });

          for (const key in obj) if (!obj[key] || (Array.isArray(obj[key]) && !obj[key].length)) delete obj[key];
          realityAnalysis.push(obj);
        }
      });

      return JSON.stringify({ termLog, realityAnalysis }, null, 2);
    }
  </script>
</body>
</html>